extends layout
include mixins

block content
    section.episode-detail
        .episode-hero
            if episode.showId && episode.showId.image && episode.showId.image.url
                .episode-cover
                    img(src=episode.showId.image.url alt=episode.title)

            .episode-meta
                if episode.showId
                    a.show-link(href=`/shows/${episode.showId.slug}`)= episode.showId.title

                h1.episode-title= episode.title

                .episode-date= new Date(episode.airDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })

                if episode.duration
                    .episode-duration Duration: #{Math.floor(episode.duration / 60)} min

        //- Player principale
        .episode-player(x-data="episodePlayer()")
            //- Usa URL diretto se disponibile (B2/Cloudinary), altrimenti fallback locale
            if episode.audioFile && (episode.audioFile.url || episode.audioFile.exists)
                - var audioUrl = episode.audioFile.url || `/uploads/episodes/${episode.audioFile.storedFilename}`
                audio#player-audio-episode(x-ref="audio" src=audioUrl preload="none" crossorigin="anonymous")

                .player-main
                    button.btn-play-large(@click="togglePlay")
                        span(x-show="!playing") â–¶
                        span(x-show="playing") â¸

                    .player-progress
                        .progress-bar(@click="seek($event)")
                            .progress-fill(:style="`width: ${progress}%`")
                        .time-info
                            span(x-text="formatTime(currentTime)")
                            span(x-text="formatTime(duration)")

                    .volume-control
                        button(@click="toggleMute")
                            span(x-show="!muted") ðŸ”Š
                            span(x-show="muted") ðŸ”‡
                        input(type="range" min="0" max="100" x-model="volume" @input="setVolume")

            .external-players
                if episode.externalLinks && episode.externalLinks.mixcloudUrl
                    a.external-btn.mixcloud(href=episode.externalLinks.mixcloudUrl target="_blank" rel="noopener") Listen on Mixcloud
                if episode.externalLinks && episode.externalLinks.spotifyUrl
                    a.external-btn.spotify(href=episode.externalLinks.spotifyUrl target="_blank" rel="noopener") Listen on Spotify
                if episode.externalLinks && episode.externalLinks.youtubeUrl
                    a.external-btn.youtube(href=episode.externalLinks.youtubeUrl target="_blank" rel="noopener") Watch on YouTube

        //- Descrizione
        if episode.description
            .episode-description
                h2 About this episode
                p= episode.description

        //- Episodi correlati
        if relatedEpisodes && relatedEpisodes.length
            section.related-episodes
                h2.section-title
                    span.title-box.cyan MORE FROM THIS SHOW

                .related-list
                    each related in relatedEpisodes
                        .related-item
                            a(href=`/episodes/${related._id}`)
                                span.related-title= related.title
                                span.related-date= new Date(related.airDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })

        .back-links
            if episode.showId
                .back-link
                    a(href=`/shows/${episode.showId.slug}`) â† Back to #{episode.showId.title}
            .back-link
                a(href="/shows") â† All shows

    script.
        function episodePlayer() {
            return {
                playing: false,
                muted: false,
                volume: 80,
                currentTime: 0,
                duration: 0,
                progress: 0,

                init() {
                    const audio = this.$refs.audio;
                    if (!audio) return;

                    audio.addEventListener('loadedmetadata', () => {
                        this.duration = audio.duration;
                    });

                    audio.addEventListener('timeupdate', () => {
                        this.currentTime = audio.currentTime;
                        this.progress = (audio.currentTime / audio.duration) * 100;
                    });

                    audio.addEventListener('ended', () => {
                        this.playing = false;
                        this.progress = 0;
                    });

                    audio.volume = this.volume / 100;
                },

                togglePlay() {
                    const audio = this.$refs.audio;
                    if (this.playing) {
                        audio.pause();
                    } else {
                        audio.play();
                    }
                    this.playing = !this.playing;
                },

                toggleMute() {
                    this.muted = !this.muted;
                    this.$refs.audio.muted = this.muted;
                },

                setVolume() {
                    this.$refs.audio.volume = this.volume / 100;
                },

                seek(event) {
                    const audio = this.$refs.audio;
                    const bar = event.currentTarget;
                    const percent = event.offsetX / bar.offsetWidth;
                    audio.currentTime = percent * audio.duration;
                },

                formatTime(seconds) {
                    if (!seconds || isNaN(seconds)) return '0:00';
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                }
            };
        }
